---
phase: 07-cli-interface-and-slash-commands
plan: 02
type: execute
---

<objective>
Add MCP prompts for slash command integration in Claude Code

Purpose: Enable users to type `/share` and `/import` in Claude Code conversations as natural slash commands, providing a more integrated experience than tool calling.
Output: MCP prompts registered in the server, accessible as `/mcp__claude-session-share__share` and `/mcp__claude-session-share__import` slash commands.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-cli-interface-and-slash-commands/07-01-SUMMARY.md
@src/index.ts
@src/cli.ts

**Tech stack available:**
- MCP SDK with prompt support (ListPromptsRequestSchema, GetPromptRequestSchema)
- Existing share_session and import_session tools

**Established patterns:**
- MCP server with stdio transport
- Tool registration via ListToolsRequestSchema
- Request handlers for tool execution

**From Plan 1:**
- CLI interface working standalone
- MCP server importable from index.ts
- Both CLI and MCP modes coexist

**MCP Prompt Integration:**
Based on MCP specification, prompts are templates that can include arguments. When registered, they appear as slash commands in Claude Code in the format `/mcp__servername__promptname`.

Prompts vs Tools:
- Tools: Claude decides when to call them (current implementation)
- Prompts: User explicitly invokes via slash commands (what we're adding)

Both can coexist - tools for natural language usage ("share my session"), prompts for explicit slash commands (/share).
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add MCP prompt handlers to index.ts</name>
  <files>src/index.ts</files>
  <action>
Add MCP prompt support to the existing MCP server:

1. Import prompt schemas:
```typescript
import {
  ListPromptsRequestSchema,
  GetPromptRequestSchema,
} from "@modelcontextprotocol/sdk/types.js";
```

2. Add prompts capability to server initialization:
```typescript
const server = new Server(
  { name: "claude-session-share", version: "0.1.0" },
  {
    capabilities: {
      tools: {},
      prompts: {}, // Add this
    },
  }
);
```

3. Register ListPrompts handler:
```typescript
server.setRequestHandler(ListPromptsRequestSchema, async () => {
  return {
    prompts: [
      {
        name: "share",
        description: "Share current Claude Code session to GitHub Gist",
        arguments: [
          {
            name: "session_path",
            description: "Optional: Path to session file (defaults to most recent)",
            required: false,
          },
        ],
      },
      {
        name: "import",
        description: "Import shared session from GitHub Gist URL",
        arguments: [
          {
            name: "gist_url",
            description: "GitHub Gist URL (e.g., https://gist.github.com/user/abc123)",
            required: true,
          },
          {
            name: "project_path",
            description: "Optional: Local project directory (defaults to current directory)",
            required: false,
          },
        ],
      },
    ],
  };
});
```

4. Register GetPrompt handler that returns prompt text:
```typescript
server.setRequestHandler(GetPromptRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;

  if (name === "share") {
    const sessionPath = args?.session_path;
    return {
      description: "Share session to GitHub Gist",
      messages: [
        {
          role: "user",
          content: {
            type: "text",
            text: sessionPath
              ? `Share my session from ${sessionPath} to GitHub Gist`
              : "Share my current session to GitHub Gist",
          },
        },
      ],
    };
  }

  if (name === "import") {
    const gistUrl = args?.gist_url;
    const projectPath = args?.project_path;

    if (!gistUrl) {
      throw new Error("gist_url argument is required");
    }

    return {
      description: "Import session from Gist",
      messages: [
        {
          role: "user",
          content: {
            type: "text",
            text: projectPath
              ? `Import session from ${gistUrl} to ${projectPath}`
              : `Import session from ${gistUrl}`,
          },
        },
      ],
    };
  }

  throw new Error(`Unknown prompt: ${name}`);
});
```

The prompts return messages that Claude then processes using the existing tools. This creates a clean separation: slash commands → prompts → natural language → tools.

DO NOT duplicate tool logic in prompts - prompts just generate natural language that triggers the existing tool handlers.
  </action>
  <verify>
- `npm run build` succeeds
- TypeScript compilation clean
- Server starts without errors: `node dist/index.js` (via stdio)
  </verify>
  <done>
MCP prompt handlers registered, prompts list share and import commands, GetPrompt returns appropriate message templates, no TypeScript errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Add prompt integration tests</name>
  <files>src/__tests__/prompts.test.ts</files>
  <action>
Create comprehensive tests for MCP prompt functionality:

1. Test ListPrompts returns correct prompt definitions
2. Test GetPrompt for "share" without arguments
3. Test GetPrompt for "share" with session_path
4. Test GetPrompt for "import" with gist_url
5. Test GetPrompt for "import" with both gist_url and project_path
6. Test GetPrompt errors on unknown prompt name
7. Test GetPrompt errors when "import" missing gist_url

Structure:
```typescript
import { describe, it, expect } from 'vitest';
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import {
  ListPromptsRequestSchema,
  GetPromptRequestSchema,
} from '@modelcontextprotocol/sdk/types.js';

describe('MCP Prompts', () => {
  let server: Server;

  beforeEach(() => {
    // Initialize server same as in index.ts
  });

  it('should list share and import prompts', async () => {
    const result = await server.handleRequest({
      method: 'prompts/list',
      params: {},
    });
    expect(result.prompts).toHaveLength(2);
    expect(result.prompts[0].name).toBe('share');
    expect(result.prompts[1].name).toBe('import');
  });

  it('should return share prompt without arguments', async () => {
    const result = await server.handleRequest({
      method: 'prompts/get',
      params: { name: 'share', arguments: {} },
    });
    expect(result.messages[0].content.text).toContain('current session');
  });

  // ... more tests
});
```

Focus on testing the MCP protocol interaction, not the underlying uploadSession/importSession services (those are already tested).
  </action>
  <verify>
- `npm test` passes all tests including new prompt tests
- All 337+ existing tests still pass
- New tests verify prompt registration and message generation
  </verify>
  <done>
Prompt test suite passing, tests cover ListPrompts and GetPrompt handlers, error cases handled, all tests green
  </done>
</task>

<task type="auto">
  <name>Task 3: Update README with slash command usage</name>
  <files>README.md</files>
  <action>
Add "Slash Commands" section to README after the "Usage" section:

```markdown
### Using Slash Commands

Claude Code users can invoke commands directly via slash commands:

#### Share Command

Type in any Claude Code conversation:
```
/mcp__claude-session-share__share
```

With specific session:
```
/mcp__claude-session-share__share session_path=/path/to/session.jsonl
```

#### Import Command

```
/mcp__claude-session-share__import gist_url=https://gist.github.com/user/abc123
```

With custom project path:
```
/mcp__claude-session-share__import gist_url=https://gist.github.com/user/abc123 project_path=/my/project
```

**Note:** Slash commands are available in Claude Code 0.9.0+. They appear in autocomplete when you type `/mcp`.

### Three Ways to Use

1. **Natural Language** (via MCP tools) - "Share my session"
2. **Slash Commands** (via MCP prompts) - `/mcp__claude-session-share__share`
3. **CLI** (standalone) - `npx claude-session-share share`

All three methods use the same underlying implementation and provide identical functionality.
```

Also update the "Features" section to mention slash command support:
- Add bullet: "⚡ Slash Commands - Direct invocation via `/share` and `/import`"

DO NOT remove existing natural language or CLI documentation - all three usage modes are equally valid.
  </action>
  <verify>
- README.md has new "Slash Commands" section with examples
- "Three Ways to Use" section explains all usage modes
- Features list mentions slash command support
- All existing documentation preserved
  </verify>
  <done>
README documents slash command usage, shows all three usage modes (natural language, slash commands, CLI), examples clear and accurate
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npm test` passes all tests (337+ including new prompt tests)
- [ ] MCP server starts without errors
- [ ] README documents slash command usage
- [ ] No TypeScript errors
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- MCP prompts registered (share and import)
- Prompt handlers return appropriate message templates
- Tests cover prompt functionality
- README documents all three usage modes
- Phase 7 complete - CLI interface and slash commands both working
  </success_criteria>

<output>
After completion, create `.planning/phases/07-cli-interface-and-slash-commands/07-02-SUMMARY.md`:

# Phase 7 Plan 2: MCP Slash Commands Summary

**[Substantive one-liner - what shipped]**

## Accomplishments

- [Key outcomes]

## Files Created/Modified

- `src/index.ts` - Added MCP prompt handlers (ListPrompts, GetPrompt)
- `src/__tests__/prompts.test.ts` - Prompt integration test suite
- `README.md` - Added slash command documentation

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Phase 7 complete! All functionality shipped:
- ✓ MCP tools for natural language usage
- ✓ MCP prompts for slash commands
- ✓ Standalone CLI for terminal usage
</output>
