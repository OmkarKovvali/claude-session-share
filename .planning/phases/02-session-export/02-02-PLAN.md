---
phase: 02-session-export
plan: 02
type: execute
---

<objective>
Implement session file discovery and metadata extraction to enable finding and summarizing Claude Code sessions.

Purpose: Build on the core reader to discover all sessions for a project and extract useful metadata (message count, timestamps, project path).
Output: Session finder that locates all JSONL files for a project, metadata extractor, and comprehensive test suite validating the full reading pipeline.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-session-export/02-RESEARCH.md
@.planning/phases/02-session-export/02-01-SUMMARY.md
@src/session/types.ts
@src/session/reader.ts
@src/utils/path-encoding.ts
@package.json

**Tech stack available:** @modelcontextprotocol/sdk@1.0.4, typescript@5.7.3, vitest@4.0.16, Node.js built-ins (fs/promises, readline, crypto)

**Established patterns:**
- MCP server with stdio transport
- Test files in src/__tests__/ directory
- ES module configuration
- Streaming JSONL reading with error recovery
- TypeScript discriminated unions for message types

**From 02-01 (previous plan):**
- Session types defined with discriminated unions
- Path encoding utilities matching Claude Code's scheme
- Streaming JSONL reader with per-line error recovery

**Research insights:**
- Session files: `~/.claude/projects/{encoded-dir}/{uuid}.jsonl` for main sessions
- Agent sessions: `~/.claude/projects/{encoded-dir}/agent-{uuid}.jsonl` for sidechain conversations
- Both main and agent files should be discovered (research Pitfall 5)
- Metadata extraction pattern from research code examples
- Test against actual session files if available in development environment
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement session file finder</name>
  <files>src/session/finder.ts</files>
  <action>
Create `src/session/finder.ts` implementing session discovery from research code example "Find all session files for a project". Implement:

1. `findSessionFiles(projectPath: string): Promise<SessionFile[]>`
   - Get home directory from process.env.HOME || process.env.USERPROFILE (throw if neither exists)
   - Use getSessionDirectory() from path-encoding.ts to get encoded session directory path
   - Use fs/promises readdir() to list files in session directory
   - Filter for .jsonl files only
   - Detect agent sessions: filename starts with 'agent-'
   - Extract sessionId: remove 'agent-' prefix if present, remove '.jsonl' extension
   - Return array of SessionFile objects with {path, sessionId, isAgent}
   - Handle ENOENT gracefully: if directory doesn't exist, return empty array (not an error)

Use Node.js fs/promises built-in module. Follow research pattern exactly - this is verified working code. Handle both main session files (uuid.jsonl) and agent session files (agent-uuid.jsonl) to avoid Pitfall 5.
  </action>
  <verify>npm run build succeeds. finder.ts exports findSessionFiles function. Returns both main and agent session files when present.</verify>
  <done>Session file finder implemented. Discovers both main and agent sessions. Handles missing directories gracefully. Returns SessionFile array with path, sessionId, and isAgent flag.</done>
</task>

<task type="auto">
  <name>Task 2: Add metadata extraction from session messages</name>
  <files>src/session/metadata.ts</files>
  <action>
Create `src/session/metadata.ts` implementing metadata extraction from research code example. Define:

1. SessionMetadata interface:
   - sessionId: string
   - projectPath: string
   - messageCount: number
   - firstTimestamp: string
   - lastTimestamp: string
   - hasAgentConversations: boolean
   - version: string

2. `extractMetadata(messages: SessionMessage[]): SessionMetadata | null`
   - Return null if messages array empty
   - Get firstMessage = messages[0], lastMessage = messages[messages.length - 1]
   - Find first user message to extract cwd and version (research pattern)
   - Use Array.find() with type guard: `messages.find(m => m.type === 'user') as UserMessage | undefined`
   - Detect agent conversations: `messages.some(m => m.isSidechain === true)`
   - Build metadata object with all fields
   - Use 'unknown' as fallback for missing cwd/version

Follow research code example exactly. Use TypeScript discriminated unions to safely access UserMessage fields only when type is confirmed.
  </action>
  <verify>npm run build succeeds. metadata.ts exports SessionMetadata interface and extractMetadata function. Returns null for empty arrays, metadata object for valid sessions.</verify>
  <done>Metadata extraction implemented. Extracts session ID, project path from user messages, message count, timestamps, and agent conversation detection. Handles missing fields with safe fallbacks.</done>
</task>

<task type="auto">
  <name>Task 3: Add comprehensive tests for session reading pipeline</name>
  <files>src/__tests__/session-reader.test.ts, src/__tests__/path-encoding.test.ts</files>
  <action>
Create comprehensive test suite covering the session reading infrastructure:

**`src/__tests__/path-encoding.test.ts`:**
- Test encodeProjectPath: `/Users/name/project` â†’ `-Users-name-project`
- Test decodeProjectPath: reverse of encoding
- Test getSessionDirectory: constructs correct ~/.claude/projects/{encoded} path
- Edge cases: paths with multiple slashes, trailing slashes

**`src/__tests__/session-reader.test.ts`:**
- Test parsing valid JSONL session (create minimal test fixture with 3-4 lines)
- Test error recovery: JSONL with one malformed line continues processing remaining lines
- Test empty lines skipped (blank lines shouldn't break parsing)
- Test missing required fields: lines without uuid/sessionId/type are skipped with warning
- Test metadata extraction: verify all fields populated correctly
- Test metadata extraction with empty message array returns null
- Test session file finder (if possible - may need mock fs or skip if complex)

Use Vitest's `describe`, `it`, `expect` patterns established in Phase 1. Create minimal test fixtures (small JSONL snippets) rather than large real sessions. Focus on testing error recovery and edge cases from research pitfalls.

If testing finder.ts requires complex mocking, add a comment indicating manual testing against real ~/.claude/projects/ directory is recommended and skip automated test for finder.
  </action>
  <verify>npm test passes all tests. Test coverage includes happy path, error recovery, empty lines, missing fields, and metadata extraction.</verify>
  <done>Comprehensive test suite created. Tests validate path encoding, JSONL parsing with error recovery, empty line handling, missing field detection, and metadata extraction. All tests pass.</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npm test` passes all tests
- [ ] No TypeScript errors in strict mode
- [ ] Session finder handles both main and agent sessions
- [ ] Metadata extraction works with empty and populated sessions
- [ ] Error recovery validated in tests
- [ ] Phase 2 goal met: can read and parse Claude Code session files
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Session discovery finds both main and agent files
- Metadata extraction handles all fields safely
- Test suite validates core functionality and error recovery
- Phase 2 complete: session reading infrastructure ready for Phase 3 (Privacy Sanitization)
  </success_criteria>

<output>
After completion, create `.planning/phases/02-session-export/02-02-SUMMARY.md`:

# Phase 2 Plan 2: Session Discovery & Metadata Summary

**[Substantive one-liner - what shipped, not "plan complete"]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `path/to/file.ts` - Description
- `path/to/another.ts` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Phase 2 complete. Ready for Phase 3 (Privacy Sanitization).
</output>
