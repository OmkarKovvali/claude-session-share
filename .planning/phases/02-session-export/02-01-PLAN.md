---
phase: 02-session-export
plan: 01
type: execute
---

<objective>
Build core session reading infrastructure with TypeScript types, path encoding utilities, and streaming JSONL parser.

Purpose: Establish the foundation for reading Claude Code session files efficiently and safely, handling large sessions without memory issues.
Output: Working session type definitions, path encoding/decoding utilities, and streaming JSONL reader with error recovery.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-session-export/02-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@src/index.ts
@package.json

**Tech stack available:** @modelcontextprotocol/sdk@1.0.4, typescript@5.7.3, vitest@4.0.16

**Established patterns:**
- MCP server with stdio transport following SDK patterns
- Test files in src/__tests__/ directory
- ES module configuration throughout stack

**Constraining decisions:**
- Phase 01: Vitest over Jest for better ESM and TypeScript support
- Phase 01: Strict TypeScript from start - all new code must pass strict type checking
- Phase 01: ES2022 with Node16 modules for modern features with proper ESM resolution

**Research insights from 02-RESEARCH.md:**
- Use Node.js built-in modules (fs/promises, readline, crypto.randomUUID()) - no external dependencies needed yet
- Session files are JSONL format: one JSON object per line
- Directory encoding: `/Users/name/project` â†’ `-Users-name-project`
- Stream line-by-line to avoid memory exhaustion on large sessions
- Wrap JSON.parse() in try-catch per line for error recovery
- Three message types: user, assistant, file-history-snapshot (use discriminated unions)
- Required fields: type, uuid, sessionId, timestamp, parentUuid
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create session types and path encoding utilities</name>
  <files>src/session/types.ts, src/utils/path-encoding.ts</files>
  <action>
Create `src/session/types.ts` with TypeScript discriminated unions for session messages following research Pattern 3. Define:
- BaseMessage interface with common fields (uuid, sessionId, timestamp, parentUuid, isSidechain?)
- UserMessage extending BaseMessage with type: 'user', message: {role, content}, cwd, version, gitBranch?, isMeta?
- AssistantMessage extending BaseMessage with type: 'assistant', messageId, snapshot: {thinking, messages}
- FileHistorySnapshot extending BaseMessage with type: 'file-history-snapshot', isSnapshotUpdate, snapshot: {files}
- SessionMessage union type = UserMessage | AssistantMessage | FileHistorySnapshot
- SessionFile interface with path, sessionId, isAgent

Create `src/utils/path-encoding.ts` with path encoding functions from research Pattern 2:
- encodeProjectPath(absolutePath: string): string - replaces `/` with `-`, removes leading `-`
- decodeProjectPath(encodedName: string): string - reverses encoding
- getSessionDirectory(projectPath: string): string - builds full ~/.claude/projects/{encoded} path

Use strict TypeScript types. Export all interfaces and functions. No validation logic yet (that's in the reader).
  </action>
  <verify>npm run build succeeds with no type errors. Types file exports SessionMessage union. Path encoding file exports three functions.</verify>
  <done>Types defined with discriminated unions. Path encoding utilities created matching verified Claude Code pattern. All code passes strict TypeScript compilation.</done>
</task>

<task type="auto">
  <name>Task 2: Implement streaming JSONL reader with error recovery</name>
  <files>src/session/reader.ts</files>
  <action>
Create `src/session/reader.ts` implementing streaming JSONL parser following research Pattern 1. Implement:

1. `readSessionLines(filePath: string): AsyncGenerator<string>` - async generator using Node.js readline built-in
   - Use createReadStream with utf-8 encoding
   - Use createInterface with crlfDelay: Infinity for CRLF handling
   - Skip empty lines with line.trim() check
   - Yield non-empty lines

2. `parseSessionFile(filePath: string): Promise<SessionMessage[]>` - parse with error recovery
   - Iterate over readSessionLines()
   - Wrap JSON.parse() in try-catch PER LINE (don't fail entire file on one bad line)
   - Validate required fields exist (type, uuid, sessionId) - skip line if missing, log warning
   - Continue processing remaining lines on errors
   - Return accumulated valid messages

Use Node.js built-in modules only: `import { createReadStream } from 'fs'` and `import { createInterface } from 'readline'`. Do NOT install external dependencies like stream-json (research says readline is sufficient for this phase). Follow anti-pattern guidance: never load entire file into memory, always stream line-by-line.
  </action>
  <verify>npm run build succeeds. Reader exports both functions. No external dependencies added to package.json (Node.js built-ins only).</verify>
  <done>Streaming JSONL reader implemented with async generator pattern. Error recovery wraps each line's JSON.parse() in try-catch. Missing required fields logged as warnings and skipped. Memory-efficient streaming for large session files.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] No TypeScript errors in strict mode
- [ ] Types properly discriminated (SessionMessage union)
- [ ] Path encoding matches verified pattern from research
- [ ] Reader uses streaming (no fs.readFileSync)
- [ ] Error recovery per-line (try-catch in loop)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Session types support all three message types
- Path encoding matches Claude Code's scheme
- JSONL reader streams line-by-line with error recovery
- Code follows established TypeScript strict patterns
  </success_criteria>

<output>
After completion, create `.planning/phases/02-session-export/02-01-SUMMARY.md`:

# Phase 2 Plan 1: Core Session Reading Summary

**[Substantive one-liner - what shipped, not "plan complete"]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `path/to/file.ts` - Description
- `path/to/another.ts` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for 02-02-PLAN.md (Session Discovery & Metadata)
</output>
