---
phase: 05-session-import
plan: 01
type: execute
---

<objective>
Build session import infrastructure: gist fetching, UUID remapping, and local session writing.

Purpose: Enable fetching shared sessions from GitHub Gist and writing them to local Claude Code storage with remapped UUIDs to avoid conflicts.
Output: GistClient with fetch capability, UUIDMapper for collision-free remapping, and SessionWriter for JSONL file creation in ~/.claude/projects/
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-session-export/02-RESEARCH.md
@.planning/phases/02-session-export/02-02-SUMMARY.md
@.planning/phases/03-privacy-sanitization/03-01-SUMMARY.md
@.planning/phases/04-gist-storage/04-02-SUMMARY.md
@src/gist/client.ts
@src/session/types.ts
@src/session/reader.ts

**Tech stack available:** Octokit v5, Node.js fs/promises, readline, crypto.randomUUID()
**Established patterns:** Async generators for streaming, immutable transformations, service layer pattern, comprehensive error handling
**Constraining decisions:**
- Phase 2: Use Node.js built-ins for file operations, per-line error recovery in JSONL parsing
- Phase 3: Immutable transformations preserving originals
- Phase 4: Service layer separates orchestration from MCP handlers

**Issues being addressed:** None
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add fetchGist method to GistClient</name>
  <files>src/gist/client.ts, src/gist/types.ts, src/__tests__/gist-client.test.ts</files>
  <action>
Add fetchGist(gistId: string) method to GistClient that retrieves gist content via Octokit. Extract gist ID from URLs (supports both html_url format like "https://gist.github.com/username/abc123" and raw ID). Return GistResponse type with files object containing filename → content mappings. Handle errors: 404 for not found, 403 for private/deleted gists requiring auth. Use this.octokit.rest.gists.get({ gist_id }) - follows same error handling patterns as createGist(). Add GistResponse type to types.ts if not already present (should already exist from Phase 4).

For URL parsing: Use regex to extract the gist ID portion (last segment after username). Example: "https://gist.github.com/user/abc123def456" → "abc123def456". Handle both full URLs and bare IDs.

Write comprehensive tests: mock octokit.rest.gists.get, verify ID extraction from URLs, test 404/403 error handling, verify content extraction from files object.
  </action>
  <verify>npm test passes with new gist-client.test.ts tests covering fetchGist success, URL parsing, 404, and 403 errors</verify>
  <done>fetchGist() method implemented, extracts gist ID from URLs, returns file contents, handles 404/403 errors, all tests passing</done>
</task>

<task type="auto">
  <name>Task 2: Create UUID remapper with collision avoidance</name>
  <files>src/utils/uuid-mapper.ts, src/__tests__/uuid-mapper.test.ts</files>
  <action>
Create UUIDMapper class following the pattern from 02-RESEARCH.md code examples section. Use Map to track original → new UUID mappings. Implement remap(originalUuid: string | null): string | null that generates new UUIDs via crypto.randomUUID() and caches them in the map for consistency (same input always returns same output within a mapper instance). Handle null parentUuid gracefully (return null).

Add remapMessage(message: SessionMessage): SessionMessage that creates immutable copy with remapped uuid, sessionId, and parentUuid fields. Use spread operator (...message) to preserve all other fields unchanged - follows Phase 3's immutable transformation pattern. Handle all three message types (user, assistant, file-history-snapshot) uniformly since UUID fields are in BaseMessage.

For the map: Use string keys, generate UUIDs lazily (only when first requested), ensure same original UUID always maps to same new UUID within a session import.

Write tests: verify same input → same output, verify null handling, verify immutability (original message unchanged), verify all message types, verify UUID chain preservation (parent-child relationships maintained through consistent remapping).
  </action>
  <verify>npm test passes with uuid-mapper.test.ts covering remap consistency, null handling, immutability, and message type handling</verify>
  <done>UUIDMapper class implemented with consistent remapping, null-safe, immutable transformations, all message types supported, all tests passing</done>
</task>

<task type="auto">
  <name>Task 3: Create session writer for local JSONL storage</name>
  <files>src/session/writer.ts, src/__tests__/session-writer.test.ts</files>
  <action>
Create writeSessionToLocal(messages: SessionMessage[], projectPath: string) function that writes session messages to ~/.claude/projects/ following Claude Code's storage format from 02-RESEARCH.md.

Implementation:
1. Path encoding: Use projectPath.replace(/\//g, '-').replace(/^-/, '') to encode directory name (verified pattern from Phase 2)
2. Generate new session ID: Use crypto.randomUUID() for the session filename (messages already have remapped sessionIds in their fields, but filename needs its own unique ID)
3. Build target path: path.join(homeDir, '.claude', 'projects', encodedPath, `${sessionId}.jsonl`)
4. Create directory: await fs.mkdir(directory, { recursive: true }) - handles missing ~/.claude/projects/ gracefully
5. Format JSONL: messages.map(m => JSON.stringify(m)).join('\n') + '\n' - one message per line with trailing newline (matches export format from Phase 4)
6. Write atomically: Use fs.writeFile(targetPath, jsonlContent, { encoding: 'utf-8' }) - Node.js built-in following Phase 2 decision
7. Return written file path and session ID for verification

Error handling: Wrap in try-catch, throw descriptive errors for EACCES (permissions), ENOSPC (disk full), other filesystem errors. Use custom SessionWriteError class extending Error.

Tests: Mock fs.mkdir and fs.writeFile with vi.mock('fs/promises'). Verify directory creation, JSONL formatting (one per line), error handling (permissions, disk space), path encoding correctness. Use test fixtures with 2-3 messages of different types.
  </action>
  <verify>npm test passes with session-writer.test.ts covering writeSessionToLocal success, JSONL formatting, directory creation, error handling</verify>
  <done>writeSessionToLocal() implemented with Claude Code path encoding, atomic writes, comprehensive error handling, all tests passing</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] npm test passes all new tests (gist fetching, UUID remapping, session writing)
- [ ] npm run build succeeds without TypeScript errors
- [ ] All three components integrate: can fetch gist → remap UUIDs → write to local storage
- [ ] Error handling comprehensive for 404, 403, filesystem errors
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- fetchGist() retrieves gist content from GitHub with URL/ID support
- UUIDMapper provides collision-free UUID remapping with consistency
- writeSessionToLocal() writes JSONL files to correct Claude Code directory structure
- No TypeScript errors or test failures
</success_criteria>

<output>
After completion, create `.planning/phases/05-session-import/05-01-SUMMARY.md`:

# Phase 5 Plan 1: Session Import Infrastructure Summary

**[Substantive one-liner - what shipped]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `path/to/file.ts` - Description
- `path/to/another.ts` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for 05-02-PLAN.md (import_session MCP tool implementation)
</output>
