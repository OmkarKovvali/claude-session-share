---
phase: 05-session-import
plan: 02
type: execute
---

<objective>
Implement import_session MCP tool with full import orchestration pipeline.

Purpose: Provide user-facing MCP tool that fetches shared gist, remaps UUIDs, and imports as local resumable session.
Output: Registered import_session tool in MCP server that accepts gist URL/ID and returns imported session details
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-gist-storage/04-02-SUMMARY.md
@.planning/phases/05-session-import/05-01-SUMMARY.md
@src/index.ts
@src/services/session-uploader.ts
@src/gist/client.ts
@src/session/writer.ts
@src/utils/uuid-mapper.ts

**Tech stack available:** MCP SDK, Octokit v5, all Phase 5 Plan 1 infrastructure (fetchGist, UUIDMapper, writeSessionToLocal)
**Established patterns:** Service layer for orchestration, MCP tool registration (ListTools + CallTool), descriptive error responses with isError flag
**Constraining decisions:**
- Phase 4: Service layer separates business logic from MCP handlers for reuse
- Phase 4: MCP response format uses content array with text and optional isError flag
- Phase 4: Extract project name for user-friendly descriptions

**Issues being addressed:** None
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create session import service</name>
  <files>src/services/session-importer.ts, src/__tests__/session-importer.test.ts</files>
  <action>
Create importSession(gistIdOrUrl: string, projectPath: string) service function that orchestrates the full import pipeline. Follow service layer pattern from Phase 4's uploadSession().

Pipeline:
1. Initialize GistClient (handles GITHUB_TOKEN validation)
2. Fetch gist: await gistClient.fetchGist(gistIdOrUrl) - supports both URLs and bare IDs
3. Extract session JSONL: Find file with .jsonl extension in gist.files, get content string
4. Parse messages: Split by '\n', filter empty lines, JSON.parse each line into SessionMessage[] (with per-line try-catch error recovery from Phase 2 pattern)
5. Remap UUIDs: Create new UUIDMapper instance, map over messages calling mapper.remapMessage(msg)
6. Write to local: await writeSessionToLocal(remappedMessages, projectPath)
7. Return import result: { sessionPath, sessionId, messageCount, projectPath }

Error handling:
- No JSONL file in gist → descriptive error
- Gist not found (404) → clear message
- Parse errors → count and report (don't fail entire import)
- Write errors → propagate with context

Return type: ImportResult interface with sessionPath, sessionId, messageCount, projectPath fields.

Tests: Mock GistClient.fetchGist and writeSessionToLocal. Verify pipeline orchestration, JSONL extraction from files, UUID remapping applied, error handling (missing JSONL, 404, parse errors). Use module-level vi.mock pattern from Phase 4.
  </action>
  <verify>npm test passes with session-importer.test.ts covering full pipeline, JSONL extraction, UUID remapping, and error scenarios</verify>
  <done>importSession() service implemented with full orchestration, error recovery, comprehensive tests passing</done>
</task>

<task type="auto">
  <name>Task 2: Register import_session MCP tool</name>
  <files>src/index.ts, src/__tests__/mcp-integration.test.ts</files>
  <action>
Add import_session tool to MCP server following share_session pattern from Phase 4.

Tool schema (ListToolsRequestSchema handler):
- name: "import_session"
- description: "Import a shared Claude Code session from GitHub Gist URL or ID. Creates local resumable session in ~/.claude/projects/"
- inputSchema: { type: "object", properties: { gistUrl: { type: "string", description: "GitHub Gist URL (https://gist.github.com/user/id) or bare gist ID" }, projectPath: { type: "string", description: "Local project directory path where session will be imported (e.g., /Users/name/project)" } }, required: ["gistUrl", "projectPath"] }

Tool handler (CallToolRequestSchema handler):
1. Extract arguments: const { gistUrl, projectPath } = request.params.arguments
2. Validate inputs: Check gistUrl and projectPath are non-empty strings
3. Call service: const result = await importSession(gistUrl, projectPath)
4. Format success response: { content: [{ type: "text", text: `Session imported successfully!\n\nSession ID: ${result.sessionId}\nMessages: ${result.messageCount}\nLocation: ${result.sessionPath}\n\nUse 'claude --resume' to see imported session.` }] }
5. Format error response: { content: [{ type: "text", text: `Import failed: ${error.message}` }], isError: true }

Integration with existing server: Add to tools array in ListToolsRequestSchema handler, add case to switch statement in CallToolRequestSchema handler. Follows same structure as share_session from Phase 4.

Tests: Verify tool appears in ListTools response, verify handler calls importSession() with correct args, verify success response format, verify error handling (missing args, invalid gist, write failures). Mock importSession with vi.mock.
  </action>
  <verify>npm test passes with mcp-integration.test.ts covering import_session tool registration and handler logic</verify>
  <done>import_session tool registered, handler implemented with validation and error handling, all tests passing</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] npm test passes all tests (250+ tests total)
- [ ] npm run build succeeds without TypeScript errors
- [ ] import_session tool appears in MCP tool list
- [ ] Full import pipeline works: gist URL → local session file
- [ ] Error handling comprehensive (404, parse errors, write errors)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- importSession() service orchestrates full import pipeline
- import_session MCP tool registered and functional
- Imported sessions written to correct ~/.claude/projects/ directory
- User-friendly success/error messages
- No TypeScript errors or test failures
- Phase 5 complete - ready for Phase 6 end-to-end verification
</success_criteria>

<output>
After completion, create `.planning/phases/05-session-import/05-02-SUMMARY.md`:

# Phase 5 Plan 2: Import Tool Implementation Summary

**[Substantive one-liner - what shipped]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `path/to/file.ts` - Description
- `path/to/another.ts` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Phase 5 complete. Ready for Phase 6 (End-to-End Verification) - will test full round-trip: share → import → resume
</output>
